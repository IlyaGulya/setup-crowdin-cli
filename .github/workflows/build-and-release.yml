name: Build and Push Crowdin CLI Binaries

on:
  schedule:
    # Run every day at 00:00 UTC
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      version:
        description: 'Crowdin CLI version to build (e.g. 3.16.0)'
        required: false
        type: string
      force:
        description: 'Force rebuild even if version already exists'
        required: false
        type: boolean
        default: false
      mark_as_latest:
        description: 'Mark this version as latest'
        required: false
        type: boolean
        default: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  JAVA_VERSION: '23'
  REGISTRY: ghcr.io
  BASE_IMAGE_NAME: ${{ github.repository_owner }}/crowdin-cli

jobs:
  check-for-updates:
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{ steps.check-version.outputs.new_version }}
      version: ${{ steps.check-version.outputs.version }}
      mark_as_latest: ${{ github.event_name == 'schedule' || inputs.mark_as_latest || (github.event_name == 'workflow_dispatch' && inputs.version == '') }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check for new Crowdin CLI version
        id: check-version
        # language=bash
        run: |
          # For manual workflow runs with specified version
          if [[ "${{ github.event_name }}" == "workflow_dispatch" && -n "${{ inputs.version }}" ]]; then
            SPECIFIED_VERSION="${{ inputs.version }}"
            echo "Using manually specified version: $SPECIFIED_VERSION"
            
            # Check if we already have this version in the container registry
            if [[ "${{ inputs.force }}" != "true" ]]; then
              echo "Checking if version $SPECIFIED_VERSION already exists in container registry..."
              if docker pull ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}:$SPECIFIED_VERSION 2>/dev/null; then
                echo "Version $SPECIFIED_VERSION already exists in container registry. Skipping."
                echo "To rebuild it, run the workflow again with force=true"
                echo "new_version=false" >> $GITHUB_OUTPUT
                exit 0
              fi
            fi
            
            echo "Will build version: $SPECIFIED_VERSION"
            echo "new_version=true" >> $GITHUB_OUTPUT
            echo "version=$SPECIFIED_VERSION" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Get the latest release from Crowdin CLI repository
          LATEST_VERSION=$(curl -s https://api.github.com/repos/crowdin/crowdin-cli/releases/latest | jq -r '.tag_name' | sed 's/^v//')
          echo "Latest Crowdin CLI version: $LATEST_VERSION"
          
          # Check if we already have this version in the container registry
          echo "Checking if version $LATEST_VERSION already exists in container registry..."
          if [[ "${{ inputs.force }}" != "true" ]] && docker pull ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}:$LATEST_VERSION 2>/dev/null; then
            echo "Version $LATEST_VERSION already exists in container registry. Skipping."
            echo "new_version=false" >> $GITHUB_OUTPUT
          else
            echo "New version $LATEST_VERSION detected. Will build it."
            echo "new_version=true" >> $GITHUB_OUTPUT
            echo "version=$LATEST_VERSION" >> $GITHUB_OUTPUT
          fi

  build-native:
    needs: check-for-updates
    if: ${{ needs.check-for-updates.outputs.new_version == 'true' }}
    runs-on: ${{ matrix.runner }}
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
            artifact: crowdin-cli-linux-amd64
          - runner: ubuntu-24.04-arm
            artifact: crowdin-cli-linux-arm64
          - runner: macos-latest
            artifact: crowdin-cli-macos-arm64
          - runner: macos-13
            artifact: crowdin-cli-macos-x86_64
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download and Extract Crowdin CLI
        # language=bash
        run: |
          VERSION=${{ needs.check-for-updates.outputs.version }}
          # Ensure VERSION has no 'v' prefix for consistency
          VERSION="${VERSION#v}"
          
          # Download the zip file (adding 'v' prefix for URL)
          echo "Downloading Crowdin CLI zip for version ${VERSION}..."
          curl -L -o crowdin-cli.zip "https://github.com/crowdin/crowdin-cli/releases/download/${VERSION}/crowdin-cli.zip"
          unzip -j crowdin-cli.zip
                    
          # Verify the JAR file was moved successfully
          if [ ! -f crowdin-cli.jar ]; then
            echo "ZIP does not contain crowdin-cli.jar"
            exit 1
          fi
          
          echo "Successfully extracted crowdin-cli.jar"

      - name: Set up GraalVM
        uses: graalvm/setup-graalvm@v1
        with:
          java-version: ${{ env.JAVA_VERSION }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Compile and package reflection feature
        # language=bash
        run: |
          # Create output directory
          mkdir -p out
          
          # Compile the reflection feature
          javac -cp crowdin-cli.jar -d out CrowdinReflectionFeature.java
          
          # Package the feature into a JAR
          jar cf feature.jar -C out .
          
          echo "Successfully compiled and packaged reflection feature"

      - name: Build native image
        # language=bash
        run: |
          native-image -Os -cp feature.jar:crowdin-cli.jar \
            -H:Features=CrowdinReflectionFeature \
            -H:IncludeResources="META-INF/services/.*|crowdin.*|messages/.*" \
            --no-fallback --enable-url-protocols=http,https \
            com.crowdin.cli.Cli \
            ${{ matrix.artifact }}

      - name: Test Crowdin CLI
        run: |
          chmod +x ./${{ matrix.artifact }}
          cd testproject
          
          echo "Testing download sources..."
          ../${{ matrix.artifact }} download sources
          
          echo "Testing download translations..."
          ../${{ matrix.artifact }} download translations
          
          echo "Testing upload sources..."
          ../${{ matrix.artifact }} upload sources
          
          echo "Testing upload translations..."
          ../${{ matrix.artifact }} upload translations
        env:
          CROWDIN_PERSONAL_TOKEN: ${{ secrets.CROWDIN_PERSONAL_TOKEN }}
          CROWDIN_PROJECT_ID: ${{ vars.CROWDIN_PROJECT_ID }}

      - name: Generate SHA256 checksum
        run: |
          sha256sum ${{ matrix.artifact }} > ${{ matrix.artifact }}.sha256

      - name: Upload binary artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.artifact }}
          path: |
            ${{ matrix.artifact }}
            ${{ matrix.artifact }}.sha256

  push-to-registry:
    needs: [check-for-updates, build-native]
    if: ${{ needs.check-for-updates.outputs.new_version == 'true' }}
    permissions:
      contents: read
      packages: write
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: binaries
          merge-multiple: false

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to the Container registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # Push architecture-specific containers
      - name: Push architecture-specific containers
        run: |
          VERSION="${{ needs.check-for-updates.outputs.version }}"
          MARK_AS_LATEST="${{ needs.check-for-updates.outputs.mark_as_latest }}"
          
          # Create and push a container for each architecture
          for ARCH_DIR in binaries/*; do
            ARCH_NAME=$(basename "$ARCH_DIR")
            ARCH_TAG=${ARCH_NAME#crowdin-cli-}
            
            echo "Creating container for $ARCH_NAME (tag: $ARCH_TAG)"
            
            # Create a Dockerfile for this architecture
            cat > Dockerfile << EOF
          FROM scratch
          LABEL org.opencontainers.image.description="Crowdin CLI v${VERSION} native binary for ${ARCH_TAG}"
          LABEL org.opencontainers.image.source="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.version="${VERSION}"
          
          # Add the binary to the image
          COPY binaries/${ARCH_NAME}/${ARCH_NAME} /
          
          # This is just a storage container, not meant to be run directly.
          CMD ["echo", "This is a storage container for Crowdin CLI binary. Not meant to be run directly."]
          EOF
            
            # Build and push the architecture-specific image
            if [[ "$MARK_AS_LATEST" == "true" ]]; then
              echo "Tagging as both ${VERSION} and latest"
              docker buildx build \
                --push \
                --tag ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}-${ARCH_TAG}:${VERSION} \
                --tag ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}-${ARCH_TAG}:latest \
                .
            else
              echo "Tagging as ${VERSION} only"
              docker buildx build \
                --push \
                --tag ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}-${ARCH_TAG}:${VERSION} \
                .
            fi
          done
          
      # Push a dummy container for version checking
      - name: Push version marker container
        run: |
          VERSION="${{ needs.check-for-updates.outputs.version }}"
          MARK_AS_LATEST="${{ needs.check-for-updates.outputs.mark_as_latest }}"
          
          # Create a simple Dockerfile for version marker
          cat > Dockerfile << EOF
          FROM scratch
          LABEL org.opencontainers.image.description="Crowdin CLI v${VERSION} version marker"
          LABEL org.opencontainers.image.source="https://github.com/${{ github.repository }}"
          LABEL org.opencontainers.image.version="${VERSION}"
          
          # Create an empty file to make the image valid
          COPY README.md /version-marker
          
          # This is just a marker container for version checking
          CMD ["echo", "This is a version marker container for Crowdin CLI v${VERSION}"]
          EOF
          
          # Build and push the version marker image
          if [[ "$MARK_AS_LATEST" == "true" ]]; then
            echo "Tagging version marker as both ${VERSION} and latest"
            docker buildx build \
              --push \
              --tag ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}:${VERSION} \
              --tag ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}:latest \
              .
          else
            echo "Tagging version marker as ${VERSION} only"
            docker buildx build \
              --push \
              --tag ${{ env.REGISTRY }}/${{ env.BASE_IMAGE_NAME }}:${VERSION} \
              .
          fi
